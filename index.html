<html>
  <head>
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
	<script src="https://code.createjs.com/1.0.0/soundjs.min.js"></script>

    <script> 
	
	var relations = {'ball': ['sphere', 'toy', 'throw', 'game equipment'], 'marble': ['rock', 'ball', 'stone'], 'goal': ['end', 'score', 'game equipment'], 'net': ['internet', 'game equipment', 'trap', 'goal'], 'target': ['end', 'sport equipment', 'victim', 'reference', 'place', 'spot', 'goal'], 'purpose': ['end', 'resolution', 'resolve', 'goal'], 'intention': ['end', 'goal'], 'aim': ['end', 'direction', 'way', 'goal'], 'intent': ['end', 'signification', 'significance', 'meaning', 'goal'], 'destination': ['end', 'terminal', 'direction', 'goal'], 'basket': ['container', 'score', 'goal'], 'objective': ['end', 'goal'], 'cage': ['net', 'constraint', 'restraint', 'enclosure'], 'fishnet': ['net'], 'shoe': ['footwear'], 'calceus': ['shoe'], 'sneaker': ['shoe'], 'walker': ['shoe', 'traveler'], 'sandal': ['shoe'], 'footwear': ['wearable', 'clothing', 'wear'], 'boot': ['footwear', 'case', 'shell', 'compartment'], 'overshoe': ['footwear'], 'game equipment': ['equipment'], 'counter': ['game equipment'], 'point': ['end', 'target', 'aim', 'objective', 'score'], 'clothing': ['covering'], 'neckpice': ['clothing'], 'uniform': ['clothing'], 'dress': ['clothing'], 'outwear': ['wearable', 'clothing', 'wear'], 'handwear': ['wearable', 'clothing', 'wear'], 'attire': ['wearable', 'clothing', 'wear'], 'clothes': ['clothing'], 'geaddress': ['clothing'], 'accessory': ['wearable', 'clothing', 'wear'], 'score': ['music', 'number', 'rating', 'evaluation'], 'match': ['duplicate', 'competition', 'counterpart', 'contest', 'score', 'lighter'], 'grade': ['slope', 'rank', 'rating', 'evaluation', 'score'], 'wearable': ['covering'], 'headdress': ['wearable', 'wear'], 'neckpiece': ['wearable', 'wear'], 'will': ['intention', 'intent', 'purpose', 'aim'], 'mind': ['intention', 'intent', 'purpose', 'aim'], 'idea': ['intention', 'intent', 'purpose', 'aim'], 'sake': ['intention', 'intent', 'purpose', 'aim'], 'wear': ['covering'], 'internet': [''], 'business': ['aim', 'objective'], 'track': ['aim'], 'marcher': ['walker'], 'strider': ['walker'], 'hiker': ['walker'], 'passerby': ['walker'], 'parader': ['walker'], 'perseverance': ['purpose'], 'persistence': ['purpose'], 'tenacity': ['purpose'], 'diligence': ['purpose'], 'trap': ['device', 'hazard', 'plan'], 'pitfall': ['trap'], 'pit': ['trap'], 'entaglement': ['trap'], 'web': ['trap'], 'resolution': ['trait', 'papers'], 'decision': ['resolution'], 'determination': ['resolution'], 'stiffness': ['resolution'], 'willpower': ['resolution'], 'end': ['content', 'boundary', 'state', 'bound', 'place', 'sopt'], 'itention': ['end'], 'endpoint': ['end'], 'pole': ['end'], 'entdgame': ['end'], 'termination': ['end'], 'rise': ['grade'], 'upgrade': ['grade'], 'belt': ['accessory'], 'evaluation': ['judgment', 'assessment'], 'marking': ['evaluation'], 'rock': ['crystal']}

	class TreeNode
	{
		constructor(value, parent)
		{
			this.value = value;
			this.descendants = [];
			this.parent = parent
		}
		
		getAbsPath()
		{
			if( this.parent != undefined)
			{
				return this.parent.getAbsPath()+this.value+"/";
			}
			else
			{
				return this.value;
			}
		}
		
		addChild(newNode)
		{
			if(newNode.parent != undefined)
			{
				newNode.parent.removeChild(newNode)
			}
			this.descendants.push(newNode)
			newNode.parent = this
		}
		
		removeChild(oldNode)
		{
			if(this.descendants.includes(oldNode))
			{
				var indexOfChild = this.descendants.indexOf(oldNode)
				if( indexOfChild != -1)
				{
					this.descendants.splice(indexOfChild,1)
				}
			}
		}
	}
	var canvas = null;
	var dataTree = new TreeNode("/");
	var currentDir = dataTree
	var lostAndFoundFolder = new TreeNode("lostandfound", dataTree)
	dataTree.descendants.push(lostAndFoundFolder );
	initLostAndFoundFolder(lostAndFoundFolder);
	var historial = "Welcome to Mauri's game\nGGJ21\n\n";
	var historial = " _____                            _    _      _\n|  ___|                          | |  | |    (_)\n| |__  __   __  ___  _ __  _   _ | |_ | |__   _  _ __    __ _\n|  __| \\ \\ / / / _ \\| '__|| | | || __|| '_ \\ | || '_ \\  / _` |\n| |___  \\ V / |  __/| |   | |_| || |_ | | | || || | | || (_| |\n\\____/   \\_/   \\___||_|    \\__, | \\__||_| |_||_||_| |_| \\__, |\n                            __/ |                        __/ |\n                           |___/                        |___/\n          _                      _              _\n         (_)                    | |            | |\n          _  ___                | |  ___   ___ | |_\n         | |/ __|               | | / _ \\ / __|| __|\n         | |\\__ \\               | || (_) |\\__ \\| |_\n         |_||___/               |_| \\___/ |___/ \\__|\n\n\n                                /              _            \\\n                               (  _ __  _|   _|_ _    __  _| )\n                                \\(_|| |(_|    | (_)|_|| |(_|/\n\nGGJConsole O.S. 2.0.21\nType 'help' for more information.\n\n";
	var prompt = ">";
	var linea = "";
	var path ="/";
	var isLSAvailable = false;
//	var isPWDAvailable = false;
	var isCDAvailable = false;
	var isMVAvailable = false;
	var isPointsAvailable = false
	var text = new createjs.Text(historial + path + prompt + linea, "20px Courier New", "#00ff00");
	text.lineHeight = 20;
	var stage;// = new createjs.Stage("demoCanvas");
	var sfxIds =["keyboard-01","keyboard-02","keyboard-03","keyboard-04","keyboard-05","keyboard-06","keyboard-07","keyboard-08","keyboard-09","keyboard-10"]


    function init() {
		canvas = document.getElementById('demoCanvas')
		text.lineWidth = canvas.width
		stage = new createjs.Stage("demoCanvas");
		stage.addChild(text)
        stage.update();
		
		sfxIds.forEach(id => createjs.Sound.registerSound("sounds/"+id+".mp3", id))
    }
	
	function findNodeInDataTree(pathToCheck, structure)
	{
		var folderList = pathToCheck.split("/");
		if( pathToCheck.charAt(pathToCheck.length-1) == '/')
		{
			//the last element is empty
			folderList.pop();
		}
		
		if( pathToCheck.charAt(0) == "/")
		{
			//absolute path
			folderList[0] = dataTree.value;
		}
		
		if( folderList[0] !== structure.value)
		{
			//the path is not relative to the folder
			return undefined;
		}
		
		var currentFolder = structure;
		for (var i = 1; i < folderList.length && currentFolder != undefined ; i++)
		{
			if(folderList[i] == ".")
			{
				continue;
			}
			else if (folderList[i] == "..")
			{
				currentFolder = currentFolder.parent;
			}
			else
			{
				currentFolder = currentFolder.descendants.find(elem => elem.value == folderList[i])
			}
		}
		
		return currentFolder
	}
	
	function printFoldersAtLocation(absPath)
	{
		
		var currentLocation = null
		
		if(absPath != undefined)
		{
			currentLocation = findNodeInDataTree(absPath, dataTree);
		}
		else
		{
			currentLocation = findNodeInDataTree(path, dataTree);
		}
		
		if (currentLocation != undefined)
		{
			currentLocation.descendants.forEach(element =>addToHistorial(element.value + "\t"));
		}
		addToHistorial("\n\n");
	}
	function printPath()
	{
		addToHistorial(currentDir.getAbsPath()+"\n\n")
	}
	function getArgsAbsPath(inPath)
	{
		var tmpPath = inPath.slice(0)

		if(tmpPath.charAt(tmpPath.length-1) != "/")
		{
			tmpPath += "/";
		}

		if( tmpPath.charAt(0) != "/" )
		{
			//relative path
			tmpPath = path + tmpPath;
		}
		
		return tmpPath;
	}
	
	function countArguments(matchList)
	{
		//return Math.max(0, matchList.filter(arg => arg != "").length-2);
		return Math.max(0, matchList.filter(arg => ((arg != "") && (arg != undefined))).length-2);
	}
	function printHelp(helpDict)
	{
		var minSpace = 3
		var maxVerticalAlign = 10
		var keyLength = 0
		var spaces = "                         ";
		for( key in helpDict)
		{
			keyLength = Math.max(keyLength, key.length)
		}
		
		var vertAlign = Math.max(keyLength+minSpace, maxVerticalAlign)

		var re = new RegExp(".{1,"+(66-vertAlign)+"}(\s|$)","g");
		for( key in helpDict)
		{
			var splitedLine = helpDict[key].match(re);
			for( var index = 0; index < splitedLine.length; index++)
			{
				if( index == 0)
				{
					addToHistorial(key+spaces.slice(0,vertAlign-key.length)+splitedLine[index]+"\n");
				}
				else
				{
					addToHistorial(spaces.slice(0,vertAlign)+splitedLine[index]+"\n");
				}
			}
		}
		addToHistorial("\n")
	}
	function parseCommand(commandLine) {
		var re = /\s*(\b\w*\b)\s*(-?\.?\.?\/?(?:\b[^ ]*\b)?\/?)?\s*(-?\.?\.?\/?(?:\b[^ ]*\b)?\/?)?\s*(.*)/g;
		var argsList = [...commandLine.matchAll(re)][0]
		if( argsList == undefined)
		{
			addToHistorial("Unknown command\n\n");
			return;
		}

		var argsCount = countArguments(argsList)
		var command = argsList[1]
		var args = argsList.slice(2,2+argsCount)
		if (command == "help")
		{
			if( argsCount != 0)
			{
				addToHistorial("Usage: help\n\n");
			}
			else
			{
				helpDict = {}

				// shows available commands
				helpDict["help"] = "Displays this message"

				if (isLSAvailable)
				{
					helpDict["ls"] = "List information about the FILEs in the current directory.";

				}
//				if (isPWDAvailable)
//				{
//					helpDict["pwd"] = "Print the name of the current working directory.";
//					//addToHistorial("pwd\t\t\t\tPrint the name of the current working directory.\n");
//				}
				if (isCDAvailable)
				{
					helpDict["cd"] = "Change the current directory.";
				}
				if (isMVAvailable)
				{
					helpDict["mv"] = "move folder SRC to DST";
				}
				if (isPointsAvailable)
				{
					helpDict["ls"] = "List information about the FILEs in the current directory";
				}
				
				printHelp(helpDict)
				
				if( !isLSAvailable)
				{
					addToHistorial("[[ UNLOCKED: <ls> command ]]\n");
				}
				isLSAvailable = true;
//				isPWDAvailable = true;
			}
		}
//		else if (command == "pwd" && isPWDAvailable)
//		{
//			if( argsCount != 0)
//			{
//				addToHistorial("Usage: pwd\n\n");
//			}
//			else
//			{
//				printPath();
//			}
//		}
		else if (command == "cd" && isCDAvailable)
		{
			if( argsCount != 1)
			{
				addToHistorial("Usage: cd <NEW PATH>\n\n");
			}
			else
			{
				argPath = getArgsAbsPath(args[0])

				var tmpDir = findNodeInDataTree(argPath, dataTree)
				
				if (tmpDir == undefined)
				{
					addToHistorial("Unknown folder\n\n");
				}
				else
				{
					currentDir = tmpDir;
					path = currentDir.getAbsPath();
				}
				
				if( !isMVAvailable)
				{
					addToHistorial("[[ UNLOCKED: <mv> command ]]\n\n");
				}

				isMVAvailable = true;
			}
		}
		else if (command == "ls" && isLSAvailable)
		{
			//TODO: support -R and parameter
			if( argsCount <= 1)
			{
				var argPath = undefined
				if( argsCount == 1 )
				{
					argPath = getArgsAbsPath(args[0])
				}
				printFoldersAtLocation(argPath);


				if( !isCDAvailable)
				{
					addToHistorial("[[ UNLOCKED: <cd> command ]]\n\n");
				}
				isCDAvailable = true;
			}
			else
			{
				addToHistorial("Usage: ls\n\n");
			}
		}
		else if (command == "mv" && isMVAvailable) 
		{
			if( argsCount != 2)
			{
				addToHistorial("Usage: mv <SRC> <DST>\n\n");
			}
			else
			{
				var srcPath = getArgsAbsPath(args[0])
				var dstPath = getArgsAbsPath(args[1])

				var srcNode = findNodeInDataTree(srcPath, dataTree) || findNodeInDataTree(srcPath, currentDir)
				if(srcNode == undefined)
				{
					addToHistorial("Unknown directory: ["+args[0]+"]\n\n");
					return;
				}
				var dstNode = findNodeInDataTree(dstPath, dataTree) || findNodeInDataTree(dstPath, currentDir)
				if(dstNode == undefined)
				{
					addToHistorial("Unknown directory: ["+args[1]+"]\n\n");
					return;
				}

				dstNode.addChild(srcNode)


				if( !isPointsAvailable)
				{
					addToHistorial("[[ UNLOCKED: <points> command ]]\n\n");
				}
				isPointsAvailable = true;
			}
		}
		else if (command == "points" && isPointsAvailable)
		{
			if( argsCount != 0)
			{
				addToHistorial("Usage: points\n\n");
			}
			else
			{
				var currentPoints = GetPoints();
				addToHistorial("Current Points " + currentPoints + "\n\n");
			}
		}
		else
		{
			addToHistorial("Unknown command\n\n");
		}
	}
	
	function initLostAndFoundFolder(treeNode)
	{
		
		treeNode.descendants.push(new TreeNode("a", treeNode));
		treeNode.descendants.push(new TreeNode("b", treeNode));
		treeNode.descendants.push(new TreeNode("c", treeNode));
	}
	
	function GetPoints()
	{
		var todoNodes = [...dataTree.descendants]
		
		console.log(todoNodes)
		
	}
	
	function addToHistorial(strIn)
	{
		historial = historial + strIn
	}
	
	function formatHistorial(textElem, strIn)
	{
		textElem.text = strIn
		var bounds = text.getBounds()

		lines = strIn.split("\n")
		
		if( bounds.width > canvas.width)
		{
			// iterate and break the long line-height
		}

		while(bounds.height > canvas.height)
		{
			lines.splice(0,1)
			textElem.text = lines.join("\n")
			bounds = text.getBounds()
		}

		return strIn;
	}

	document.onkeydown = function(e)
	{
	  if(window.event) { // IE                  
		keynum = e.keyCode;
	  } else if(e.which){ // Netscape/Firefox/Opera                 
		keynum = e.which;
	  }
	if (keynum == 8)
	  {
		linea = linea.slice(0,-1);
			createjs.Sound.play(sfxIds[sfxIds.length-1]);
	  }
	  else if(keynum == 13)
	  {
			addToHistorial( path+prompt+linea + "\n");
			parseCommand(linea);
			linea = "";
			createjs.Sound.play(sfxIds[sfxIds.length-1]);
	  }
	  else
	  {
		if( e.key.length == 1)
		{
		  linea  = linea + e.key;
		}
		  var soundId = sfxIds[Math.floor(Math.random() * sfxIds.length)];
		  
		  createjs.Sound.play(soundId);
	  }
	  formatHistorial(text, historial + path +prompt+ linea);
	  stage.clear();
	  stage.addChild(text);
	  stage.update();
	  
	}
    </script>
  </head>
  <body onload="init();"  id="char" bgcolor=black>
    <canvas id="demoCanvas" width="800" height="600"></canvas>
  </body>
</html>
